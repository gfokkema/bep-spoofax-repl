\section{Problem Analysis}
\label{sec:problem-analysis}
This section gives an analysis of the problem defined in the previous
section. More specifically, this section describes the problems that
are expected and that will have to be solved while incorporating a
REPL within the larger context of Spoofax.

The general theme of the sub-problems that arise from the problem
defined in the previous section, is that the REPL that should work
with any language defined with Spoofax. Languages differ in what
properties they have and how they are specified. For example, a
functional programming language with no mutability is specified very
differently from an imperative and mutable programming
language. Finding a generic way to make the REPL work for all of these
languages, without any configuration from the part of the language
designer, is hard, and maybe not even possible.

The general solution to many of the problems is to identify which
parts of the problem can be solved generically, and which parts
warrant configuration by the language designer. When the REPL requires
configuration by the language designer, the REPL should give the
language designer enough flexibility to do the configuration with the
least amount of hassle as possible.

The rest of this section analyses more concrete sub-problems and
possible solution. Each of
\cref{ssec:supp-diff-ways,ssec:lang-spec-addit,ssec:repl-spec-semant}
discusses a more detailed instance of this general problem, and
explains in more detail how the general solution applies to that
specific instance.

%Lastly, in \cref{sec:fitt-feat-repl}, the problem of fitting the REPL
%within the larger scope of Spoofax is discussed.

\subsection{Supporting different execution pipelines}
\label{ssec:supp-diff-ways}
Different languages have different ways of executing a program in that
language. For example, some languages have an analysis step, whereas
some do not. Moreover, specifying the dynamic semantics of a language
can be done in multiple ways (see \cref{ssec:dynamic-semantics}): one
can use DynSem, Stratego, and some languages even implement a Java
backend\footnote{See IceDust:
  \url{https://github.com/MetaBorgCube/IceDust}}.

Some of these properties of a language should be detected by the REPL
automatically, such as detecting whether a language has an analysis
step.

Other properties of a language, however, cannot be detected
automatically. For example, the REPL should be able to maintain an
execution environment for the duration of the REPL session, but
precisely what an execution environment looks like differs among
languages. This is therefore an area where the language designer
should configure the REPL so that it does the evaluation as they
want. To accommodate for this, the REPL should provide a configuration
interface that is generic enough, such that the REPL can be configured
for any language.

\subsection{Language-specific additional commands}
\label{ssec:lang-spec-addit}
Another problem is when some additional command can be useful for a
REPL of a particular language, but would not make any sense within the
context of other languages. For example, some languages such as Python
allow for loading modules, which brings all of the definitions inside
of these modules into scope. An additional command to load a module
could in that case be useful, but would not make any sense in
languages that have no concept of definitions that can be imported.

This problem could be solved by the language designer by extending
their language with reflective capabilities. However, the language
designer might not want to extend the language with reflective
capabilities outside of the context of a REPL. It is clear therefore
that a different approach should be considered.

One possible solution is to allow for configurations of
language-specific commands, that are loaded with the language
definition of that language. This can be done by extending the editor
services discussed in \cref{ssec:editor-serv} with REPL
commands. Similar to menu actions, where one can define menu buttons
such as ``Run'' to run a program, one may then even bind the
``load-file'' command to an action.

\subsection{REPL-specific semantics}
\label{ssec:repl-spec-semant}
Sometimes a property of some language stands in the way of the rapid
prototyping capabilities that are desirable for a REPL. For example, a
language like Haskell does not allow for redefining a function's
implementation in its normal semantics, whereas in the context of a
REPL this is usually what one wants.

This poses a similar problem as in the previous section: changing the
language for the REPL should not affect the semantics of the language
outside of the REPL. Therefore, requiring the language designer to
extend the language with such abilities is again an inadequate
solution.

A proper solution for this problem is to allow the language designer
to define a different semantics in the context of a REPL session. For
example, in the case of a language that uses DynSem for specifying its
dynamic semantics, the language designer can provide additional rules
that are meant only for the REPL. Again, the REPL should provide a
flexible configuration interface for these REPL-specific
semantics. Another desirable property of this configuration interface
is to allow the language designer to reuse the semantics that are
common both in the context of a REPL session and outside of it.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End:
