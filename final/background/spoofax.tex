\section{The Spoofax Language Workbench}
\label{sec:spoofax}
Spoofax is a platform that allows for giving a completely \emph{declarative}
definition of a programming language and accompanying IDE
support~\cite{Kats10a}. Such a platform is called a \emph{language workbench}.

In discussing programming languages, it is useful to distinguish the following
three concepts: an \textit{aspect} of a language, the formal
\textit{specification} of that aspect, and the actual \textit{implementation} of
that aspect, which follows from the specification. Any programming language can
be divided into multiple distinct aspects. In \cref{fig:spoofax-relations}, four
common aspects of programming languages are shown, along with the relation
between the formal specification and implementation for each aspect. An example
of an aspect is the \textit{syntax definition}: its formal specification is done
with grammar rules, and its implementation consists of both a tokenizer and
parser.

A key property of Spoofax is that it allows a language designer to give a
complete specification of each aspect of their language, and automatically
derive the implementation of that language aspect from its
specification. Spoofax provides a range of high-level, declarative
\textit{meta-languages} to the language designer for declaring their language
specification.

This section goes over the aspects that come into play with the development of a
language and how Spoofax tackles each of these aspects with its
meta-languages. First, the section goes over some of the elements that make up
the specification of each language aspect\footnote{This section follows the
  structure of the language specification portion of the compiler construction
  course at the TU Delft. The slides can be found here:
  \url{http://tudelft-in4303.github.io/lectures/specification/}.}. A language
commonly consists of the following aspects, shown also in
\cref{fig:spoofax-relations}, of which a selection will be discussed in more
detail throughout the rest of this section:

\begin{enumerate}
\item \textbf{\hyperref[ssec:syntax-def]{Syntax Definition}:} The first aspect
  concerns what textual representations of a program are syntactically
  valid. Its specification consists of a grammar specified with context-free
  grammar productions. A parser provides an implementation of this
  specification, by mapping a textual representation of a program to an abstract
  syntax tree (AST) representation. In Spoofax, the syntax is declared with a
  domain specific language (DSL) called SDF.
\item \textbf{Static Semantics:} A parsed AST then optionally goes through
  static analysis (type checking, name binding and variable scoping), to test if
  the program is well-formed. Static analysis is the implementation of an aspect
  called \textit{static semantics}. The static semantics of a language can be
  formally specified by \textit{type and/or name binding rules}. Spoofax
  provides two DSLs that can specify the two distinct parts of the
  specification: the TS Type Specification language and the NaBL name binding
  language.

  This language aspect will not be discussed in this section. However, the
  original research report contains a section that does discuss this aspect, and
  can be found in \cref{ssec:a-static-analysis}.
\item \textbf{Term Rewriting or Program Transformation:} Optionally, a
  well-formed AST can then be transformed, for example for desugaring or
  optimization. This execution step falls under the aspect of \textit{term
    rewriting} and can be formally specified by \textit{term rewrite rules}. For
  the specification of this aspect, Spoofax provides a DSL called Stratego.

  This aspect, too, will not be discussed in this section. The relevant section
  in the research report can be found in \cref{ssec:a-term-rewrite}.
\item \textbf{\hyperref[ssec:dynamic-semantics]{Dynamic Semantics}:} Next the
  optionally transformed AST is either compiled or interpreted, thereby
  providing a means of execution. The aspect of \textit{dynamic semantics}
  defines what the behaviour is of a program upon execution. The formal
  specification of this aspect can be done with \textit{reduction rules},
  although there are other ways to accomplish this: for example, interpretation
  can be seen as the transformation of a program to a single value. In Spoofax,
  the dynamic semantics can be defined with either Stratego or a DSL called
  DynSem.
\end{enumerate}

\begin{figure}[t]
  \centering
  \includegraphics[width=\textwidth]{spoofax-relations}
  \caption{The relations between the aspects, specification and implementation
    of a programming language. The dashed boxes in the bottom row refer to that
    step being optional.}
  \label{fig:spoofax-relations}
\end{figure}

This section concludes with a discussion on the other part of a language: its
integrated development environment (IDE). Spoofax provides IDE support by means
of its Editor Services.

\subsection{Syntax Definition}
\label{ssec:syntax-def}
The first part of the specification of a language is its syntax. The
syntax of a language is often specified by means of a \emph{lexical
grammar} and a \emph{context-free grammar}, as can be seen in the
specification of, for example, Standard ML~\cite{Milner97}. The
lexical grammar is most often defined using regular expressions. It
defines the individual words made up of characters, such as
identifiers and numeric constants. The context-free grammar then
defines syntactically valid sentences made up of words.

\subsubsection{SDF3: syntax definition in Spoofax}
\label{ssec:orgheadline1}
To specify a syntax definition declaratively in Spoofax, a DSL called
\emph{SDF3}~\cite{Vollebregt12} is used.  SDF3 is the third generation
of the \emph{Syntax Definition Formalism} (SDF)~\cite{Heering89}. It
uses only context-free grammer productions for the specification of
both the lexical syntax and the context-free syntax, a feature that
was introduced in SDF2~\cite{Visser97}.

The declarative nature of SDF3 allows for thinking in terms of the
structure (the \emph{what}), instead of in terms of parser algorithms (the
\emph{how}) as is the case with many current parser generators such as
ANTLR and YACC~\cite{Kats10b}. The syntax definition is used to
make parsers that parse a textual representation of a program into its
AST and pretty-printers for mapping ASTs back to text. However, due to
its declarative nature, SDF3 is not limited to generating parsers and
pretty printers: it can also be used for error recovery
rules~\cite{deJonge12}, syntax highlighting rules and folding
rules for editors (see \cref{ssec:editor-serv}).

The Spoofax API gives access to the generated parser through the
\texttt{SyntaxService}.

\subsubsection{ASTs in Spoofax: Stratego Terms}
\label{sec:asts-spoof-strat}
% TODO: Reference for Stratego terms.
In Spoofax, an AST is represented as a Stratego term, a format representing tree
structures that comes with a textual representation similar to formats such as
XML. As an example, a representation of the arithmetic expression $2 + 2 - 4$ is
shown in \cref{lst:aterm-example}.

\begin{lstlisting}[caption={An example Stratego term representation of an
arithmetic expression},language=aterm,label={lst:aterm-example}]
Sub(Add(Int("2"), Int("2")), Int("4"))
\end{lstlisting}

Stratego terms can however represent any tree structure, not just ASTs. As such,
when using Spoofax programmatically through its API, one sees Stratego terms
used as an internal representation of the data going through the execution
pipeline depicted in \cref{fig:spoofax-relations}.

\subsection{Dynamic Semantics}
\label{ssec:dynamic-semantics}
Dynamic semantics refers to how a program written in some language
behaves~\cite{Winskel93}. There are many approaches to formally specify the
dynamic semantics of a programming language (for an extensive treatment,
see~\cite{Winskel93}). One way is to specify the transformation of programs
written in the programming language to programs of another language of which the
dynamic semantics are already known. For this report, however, only one sort
of approach called \emph{operational semantics} is relevant.

The first part of this subsection gives a short description of operational
semantics, and shows an example of how it can be used to specify the dynamic
semantics of a programming language. After that, a short overview of DynSem is
given, as well as the same example expressed in DynSem.

\subsubsection{Operational semantics}
\label{sec:oper-semant}
In operational semantics, the dynamic semantics are specified by a set of axioms
and reduction rules. A reduction rule consists of set of premises and a
predicate. If all of the premises of a reduction rule hold, then the predicate
also holds~\cite{Kahn87}. A predicate is structured as follows: the left-hand
side of a formula introduces a pattern, and the right-hand side instantiates the
result.

To show how rules can define the dynamic semantics of a language, consider the
classic example of the \(\beta\)-rule shown in \cref{eq:beta-reduct-structural},
which defines function application in the lambda calculus. The rule replaces all
the occurrences of the parameter \(x\) with the argument \(e_2\), within the
expression \(e_1\).

\begin{equation}\label{eq:beta-reduct-structural}
(\lambda x.e_1) e_2 \xrightarrow{\beta} e_1[x := e_2]
\end{equation}

\begin{equation*}\label{eq:beta-reduct-natural}
\infer{%
  E \vdash e_1 e_2 \rightarrow v%
  }{%
    \begin{split}
      E \vdash e_1 \rightarrow (\lambda x.b, E') \\
      (x \mapsto e_2) \circ E' \vdash b \rightarrow v
    \end{split}%
}
\end{equation*}

\subsubsection{DynSem: rule-based dynamic semantics}
\label{ssec:dynsem}
Aside from Stratego, the Spoofax team has developed an additional
method to declare the dynamic semantics of a language, namely a DSL
called \emph{DynSem}~\cite{VerguNV15}. DynSem allows for an operational
semantics specification from which a Java-based AST interpreter is
automatically generated.

\paragraph{Reduction rules} In DynSem, reduction rules are used to specify the
dynamic semantics of a language, in a syntax similar to the formal syntax like
shown in \cref{eq:beta-reduct-natural}. A reduction rule in DynSem takes the
following form~\cite{VerguNV15}:

\begin{minipage}[t]{\linewidth}
\begin{lstlisting}[language=dynsem,numbers=left,caption={The syntactic structure
of a reduction rule in DynSem.},label={lst:dynsem-rule-syntax}]
  Rs |- <term1> :: RWs --> <term2> :: RWs'
  where <premise1>;
        <premise2>.
\end{lstlisting}
\end{minipage}

The rule as shown in \cref{lst:dynsem-rule-syntax} is read as follows: given
that the conditions \texttt{premise1} and \texttt{premise2} can be satisfied,
perform a pattern-match on \texttt{term1} and instantiate the pattern
\texttt{term2} as the result of the reduction.

\paragraph{Semantic components} The variables \texttt{Rs}, \texttt{RWs} and
\texttt{RWs'} shown in \cref{lst:dynsem-rule-syntax} are called \textit{semantic
  components}: they represent the context in which the reduction takes place. An
example of a semantic component is that of an environment, which maps variable
names to their values. Another example is that of a store, which maps addresses
of values to the values themselves. There are two kinds of semantic components:
\textit{read-only} semantic components and \textit{read-write} semantic
components. An environment is a read-only semantic component: a variable is
bound only within a certain scope, and any other reduction rules that are
applied outside of that scope don't see this environment. A store is a
read-write semantic component: changes in the store are visible everywhere, as
it represents mutable state.

\paragraph{Function application in DynSem} Two examples of reduction rules are
shown in \cref{lst:dynsem}. Taken together the rules specify the semantics of
function application by using an environment, rather than replacement as done in
\cref{eq:beta-reduct-structural}:

\begin{minipage}[t]{\linewidth}
\begin{lstlisting}[language=dynsem,numbers=left,caption={Specifying function
application through the use of an environment.},label={lst:dynsem}]
rules
  E |- Fun(x, e) --> ClosV(x, e, E).

  App(ClosV(x, e, E), v1) --> v2
  where
    E  |- bindVar(x, v1) --> E';
    E' |- e --> v2.
\end{lstlisting}
\end{minipage}

The first rule, shown in line 2, captures the notion of a closure, which is
merely a function together with the environment it is defined in. The
environment variable \texttt{E} is matched on the left-hand side, and used in
the result of the rule on the right-hand side.

The second rule, corresponding to lines 4 to 7, first introduces a pattern-match
on a term representing function application. In line 6, the environment
\texttt{E} is extended with a variable binding \texttt{x -> v1} to form a new
environment \texttt{E'}. Then in line 7 the function body \texttt{e} is reduced
to the value \texttt{v2}, within the context of the newly extended environment
\texttt{E'}.

\subsection{Editor Services}
\label{ssec:editor-serv}
This section concludes with a brief description of editor services,
which provide the IDE support for languages defined in
Spoofax. Examples of such services include an outline view, menus in
which one can bind actions to menu buttons (see
\cref{fig:menu-actions}), but also syntax highlighting, syntactic code
completion and code folding rules\footnote{More services are
listed on the Spoofax website:
\url{http://www.metaborg.org/spoofax/editor-services/}}.

The Spoofax API provides the editor services with similar naming. For
example, the outline can be retrieved from the \texttt{OutlineService}, the
syntax highlighting can be accessed through the \texttt{StylerService} and
syntactic code completion is accessed with the
\texttt{CompletionService}. The defined menus for a particular language can
be retrieved with the \texttt{MenuService}, from which the menu actions can
be retrieved and used.

\begin{figure}[bt]
\centering
\includegraphics[width=0.6\textwidth]{./img/menu-actions.png}
\caption{\label{fig:menu-actions}
A menu action for the paplj language defined using Spoofax. The bottom window shows the menu definition, the top window shows a program written in paplj.}
\end{figure}

Editor services are defined using a DSL, shown in the bottom window of
\cref{fig:menu-actions}. In the case of menus, their actions are
specified using Stratego. Since Stratego supports native strategies,
these actions can also be specified in Java. As such, Spoofax allows
for defining arbitrarily complex IDE actions.

Many of these editor services such as syntax highlighting and code
folding rules can be derived from the syntax
definition~\cite{Kats10c} and can be further customized if
needed. Taken together with the language definition, the editor
services provide a language with a complete and state-of-the-art IDE
experience~\cite{Kats10a}.
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End:
