\section{Problem Analysis}
\label{sec:problem-analysis}
This section gives an analysis of the problem defined in the previous
section. More specifically, this section describes the problems that
are expected and that will have to be solved during the implementation process
of the product. The first part of this section describes the process
of incorporating a REPL within the larger context of
Spoofax. The second part analyzes the part of the problem concerned
with literate programming. This part will be analyzed in less detail
than creating a REPL as it is unsure whether it will be present in
the final product.

\subsection{Creating a REPL that works with any language defined in Spoofax}
\label{ssec:incorp-repl-spoofax}

Every language can have many different language constructs. The REPL for
Spoofax, however, should not be constrained to any particular language
constructs like classes. Rather, it should operate on any defined language. For
this reason the implementation and particularly the interaction with the user
needs to be carefully considered. This subsections lists some of the problems
that are expected to arise from this.

\subsubsection{Execution model of the REPL}
\label{ssec:execution-model-repl}
As illustrated in \cref{ssec:execution-model} a primary difference in the
execution model of a non-interactive interpreter and a REPL is concerned with
what an indivisable unit of execution is. The build process as implemented in
Eclipse uses a ``BuildInputBuilder'' to transform and build a (valid) program
as a whole. While this is quite a convenient way to quickly create a compiled
program, for a REPL to really offer an interactive experience to the user, the
REPL should be able to execute smaller units of work than a complete program.

An example implementation that solves this problem is the JShell
REPL~\cite{jshell-repl} currently under development by OpenJDK.  The OpenJDK
team introduces a concept called ``wrapping'' to achieve this: \textit{``if X
is an input that JShell accepts (as opposed to rejects with error) then there
is an A and B such that AXB is a valid program in the Java programming
language.''}. More specifically this says that when a user types in an
expression, like ``int x = 2 + 2;'', JShell generates the surrounding class and
method body needed for this expression to be valid.

This technique cannot be directly applied to Spoofax, since the language
constructs needed to sucessfully ``wrap'' constructs is not known in advance.
A first approach to solve this problem could be to require that the language
designer provides a program template in an esv file, in which he can indicate
the various types of language constructs are valid from within the REPL, and
where they would be inserted in this template.
The REPL should then be able to distinguish the language constructs defined in the esv file
as the user types them in.
A template for paplj could look like this:
\begin{lstlisting}
program
  \$classes
run
  \$expressions
\end{lstlisting}

The illustrated solution could later be extended to eliminate the need for manual specification,
by reusing the syntax definitions for the language as specified in SDF.
Given an invalid partial program as typed in by the user, the REPL could try to determine
whether this partial program is valid anywhere within the parse tree specified by SDF.
By doing a breadth-first search, starting from the context-free start symbols of the language,
the REPL could prepend symbols from the syntax definition until the program is valid.
This suggestion can then be shown to the user, after which the resulting program is executed.

\subsubsection{Detecting unfinished expressions for multiline editing}
\label{sec:detect-unfin-expr}
To support multiline editing, the REPL should detect that the
expression or statement is unfinished when the user presses the
``Return'' key for the next line, instead of trying to parse and
execute it. An obvious part of Spoofax that is relevant for this
problem, is the syntax definition in SDF3 (see
\cref{sec:orgheadline1}).

\subsubsection{Language specific additional commands}
\label{sec:lang-spec-addit}
Another problem is when some additional command can be useful for a
REPL of a particular language, but would not make any sense within the
context of other languages. For example, some languages such as Python
allow for loading a file, which brings all of the definitions inside
of it into scope. An additional command to load a file could in that
case be useful, but would not make any sense in languages that have no
concept of definitions that can be imported.

This problem could be solved by the language designer by extending
their language with reflective capabilities. However, the language
designer might not want to extend the language with reflective
capabilities outside of the context of a REPL, for example when the
language is a DSL. It is clear therefore that a different approach
should be considered.

One possible solution is to allow for language specific configurations
that are loaded with the language definition of that language. This
can be done by extending the editor services discussed in
\cref{sec:editor-serv} with REPL commands: similar to menu actions,
where one can define menu button ``Run'' to run a program, one may
define a ``load-file'' command and bind it to an action.

\subsubsection{Redefining terms bound to names}
\label{sec:redef-cont-bound}
When the user is prototyping methods inside the REPL, they would
likely want to be able to redefine that method to be of a different
implementation. However, this poses a similar problem as in the
previous section: for some languages it may not be possible nor
desirable to do so outside of the context of a REPL. Thus requiring
the language designer to extend the language with such abilities is
again an inadequate solution.

One could propose the same solution as in the previous section, namely
to define an additional command for redefining a class or
method. However, in this case this is not an adequate solution either,
since binding terms to names is a common feature among programming
languages. The fact that Spoofax comes with the NaBL DSL for
specifying name binding rules illustrates this. Name binding is in
fact the very feature which enables one to create abstractions.

A possible and more adequate solution for redefining a term bound to a
name, is to allow the user to give the name and the new term. The name
can then be used to find the old term, so that it can be replaced with
the new one.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
