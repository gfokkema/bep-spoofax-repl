#+TITLE:Research Report Notes
* Preface
These are notes for the research report. The relevant papers for each
subject are linked. A useful course by the Spoofax team with relevant
lecture slides can be found here:
[[http://tudelft-in4303.github.io/lectures/specification/]]. These are all
the lecture slides related to language specification (Formal Grammars,
[[#sec-syntax-def][Syntax Definition]], [[#sec-static-analysis][Static Semantics]], [[#sec-term-rewrite][Term Rewriting]], [[#sec-dynamic-semantics][Dynamic Semantics]])
* Syntax Definition
:PROPERTIES:
:CUSTOM_ID: sec-syntax-def
:END:
The first part of Spoofax to consider is Syntax Definition. To specify
a syntax definition declaratively, a DSL called SDF3 is used. The
syntax definition can be used to make parsers which parse text to AST,
pretty-printers for mapping ASTs back to text. Furthermore, it can be
used for error recovery rules, syntax highlighting rules and folding
rules for editors.

All the other parts of Spoofax operate on the AST that is produced by
a parser generated by a SDF3 specification.
* Static Semantics
:PROPERTIES:
:CUSTOM_ID: sec-static-analysis
:END:
Static semantics refer to the meaning of what is a well-formed
program[fn:missing-ref:Reference?]. This imposes more constraints than
syntax definition, such as name binding and name resolution, and type
checking. These cannot be specified by a syntax definition alone, and
is thus considered separately.
** Declarative Static Semantics Specification in Spoofax
In Spoofax, all the static semantics as well as the dynamic semantics
used to be specified with the Stratego transformation language (which
will be discussed in [[#sec-term-rewrite][Term Rewriting]]). Nowadays, two higher level DSLs
exist for specifying static semantic declaratively: NaBL and TS. The
two DSLs can work together: for instance, the type of a variable can
be set in NaBL, so that TS can make assertions on it.
** NaBL: the Name Binding Language
With NaBL (pronounced /enable/), name binding and scoping rules can be
specified. Here is an example of the name binding and scoping rules
for a class, from the paplj language:
#+BEGIN_EXAMPLE
namespaces Program Class Field Method Variable
// ...
binding rules
  Class(c, _, _, _) :
    defines Class c of type ClassT(c)
    // Declare new scope
    scopes Field, Method, Variable
    implicitly defines Variable This() of type ClassT(c)

  Extends(c) :
    // Import namespaces from superclass
    imports Field, Method from Class c
#+END_EXAMPLE
The first line declares the namespaces to
consider. Then for each node in the AST resulting from the parsing,
for example a =Class= node, the name binding and scoping rules can be
defined. In the example, each =Class= node declares a new scope for
its fields, methods and variables. It also implicitly defines the
=this= variable. The =Extends= node can then import the fields and
methods into its scope.

As can be seen from line 8, it can also associate type information
with names, to interplay with TS. The type annotations can also be
used for instance when desugaring or rewriting with Stratego (see [[#sec-term-rewrite][Term
Rewriting]]).
** TS: the Type Specification Language
Type checking can be done with the TS DSL. Again an example of the
paplj language:
#+BEGIN_EXAMPLE
type rules
  Class(c1, Extends(c2), _, _) :-
    where store ClassT(c1) <sub: ClassT(c2)

  x@This() : t
    where definition of x : t
// ...
type rules
  Add(e1, e2) : NumT()
    where e1 : NumT() else error "number expected" on e1
      and e2 : NumT() else error "number expected" on e2

#+END_EXAMPLE
Rules can recursively set constraints on AST-nodes, such as the =Add=
node in the above example.

Again, in line 5, interplay can be seen between TS an NaBL. Here the
type of a variable can be accessed, which is set in the NaBL
specification (see previous section).
* IN-PROGRESS Term Rewriting and Program Transformation
:PROPERTIES:
:CUSTOM_ID: sec-term-rewrite
:END:
Spoofax offers a high level declarative DSL called Stratego for program
transformation. Stratego operates on ASTs, and is the most general
part of Spoofax: it can be used for static semantics (name binding,
type checking), desugaring and for the dynamic semantics of a
language.

As the static semantics can now be done using NaBL and TS, and the
dynamic semantics with DynSem (see next section), Stratego can be used
to specify desugaring rules for a language.

Stratego is based on the notions of term rewrite rules and so called
/strategies/.
** Rewrite rules
A rewrite rule is a transformation on a term, in which
the left-hand side allows for pattern matching and variable binding,
and the right hand side instantiates new replacement terms. An example
of a rewrite rule is given below.
#+BEGIN_EXAMPLE
rules
  desugar-let :
  	Let([], e) -> e

  desugar-let :
  	Let([b1, b2 | bs], e) -> Let([b1], Let([b2 | bs], e))
#+END_EXAMPLE
This desugars a =let= expression with multiple bindings into multiple
nested =let= expressions each having just one binding.
** Strategies
Strategies are used to select and apply term rewrite rules, to
construct the main algorithm of the program transformation. One can
use multiple combinators to compose rewrite rules and other
strategies. An example is given below:
#+BEGIN_EXAMPLE
strategies
  pre-desugar =
  	innermost(desugar-let <+ desugar-do)

  post-desugar =
    innermost(desugar-do <+ desugar-get <+ desugar-set);
    resugar
#+END_EXAMPLE
For example, =innermost= is a strategy to apply the strategy given as
parameter (a composition of rewrite rules) on the innermost AST node,
and repeats doing this until it is done.
* IN-PROGRESS Dynamic Semantics
:PROPERTIES:
:CUSTOM_ID: sec-dynamic-semantics
:END:
Dynamic semantics[fn:lecture-dynsem: Relevant lecture:
http://tudelft-in4303.github.io/lectures/specification/dynamic-semantics]
(also known as /execution semantics/) refer to the semantics of what a
program in some language does when executed [fn:missing-ref].

There are multiple approaches to formally specify the dynamic
semantics of a language. Among those approaches are /small-step style/
semantics[fn:lecture-ucolorado: See for example
[[http://ecee.colorado.edu/~siek/ecen5013/spring10/lecture3.pdf]]],
/big-step style/ semantics and translating to a different language.
** Dynamic Semantics using Stratego
The dynamic semantics of a language used to be specified with
Stratego, but the Spoofax team has developed a more higher level way
to declare the semantics of a language, using [[#ssec-dynsem][DynSem]].
** DynSem
:PROPERTIES:
:CUSTOM_ID: ssec-dynsem
:END:
DynSem[fn:dynsem: Relevant paper: [[http://swerl.tudelft.nl/twiki/pub/Main/TechnicalReports/TUD-SERG-2015-003.pdf][DynSem: A DSL for Dynamic Semantics
Specification]].] is a DSL for specifying the /dynamic semantics/ of a
language.  Often the formal specification of the dynamic semantics of
a program are separate from the implementation of the language. The
goal of DynSem is to unify both of these, by providing a syntax that
is readable as a formal specification, and can also serve as the
source for generating the execution engine of a programming language.
** IN-PROGRESS Reduction Rules
With DynSem, the dynamic semantics are specified by reduction rules in
either small-step style or big-step style[fn:prefer-big-step: DynSem
prefers big-step style, as it can optimize rules of that type better.].
